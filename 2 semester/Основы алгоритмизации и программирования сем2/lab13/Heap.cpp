#include "Heap.h" // Подключаем заголовочный файл с объявлением кучи.

#include <iostream> // Подключаем библиотеку для работы с вводом/выводом.
#include <iomanip> // Подключаем библиотеку для работы с форматированным выводом.

void AAA::print() // Определение метода print() для структуры AAA.
{
	std::cout << x; // Выводим значение переменной x на экран.
}

int AAA::getPriority() const // Определение метода getPriority() для структуры AAA.
{
	return x; // Возвращаем значение переменной x.
}

namespace heap // Определяем функции и методы в пространстве имен heap.
{
	Heap create(int maxsize, CMP(*f)(void*, void*)) // Функция для создания новой кучи.
	{
		return *(new Heap(maxsize, f)); // Создаем новый объект кучи и возвращаем его.
	}

	int Heap::left(int ix) // Метод для получения индекса левого потомка узла с индексом ix.
	{
		return (2 * ix + 1 >= size) ? -1 : (2 * ix + 1); // Если индекс левого потомка находится за пределами кучи, возвращаем -1, иначе возвращаем его значение.
	}

	int Heap::right(int ix) // Метод для получения индекса правого потомка узла с индексом ix.
	{
		return (2 * ix + 2 >= size) ? -1 : (2 * ix + 2); // Если индекс правого потомка находится за пределами кучи, возвращаем -1, иначе возвращаем его значение.
	}

	int Heap::parent(int ix) // Метод для получения индекса родительского узла для узла с индексом ix.
	{
		return (ix + 1) / 2 - 1; // Вычисляем индекс родительского узла и возвращаем его значение.
	}

	void Heap::swap(int i, int j) // Метод для обмена элементами с индексами i и j в куче.
	{
		void* buf = storage[i]; // Временно сохраняем значение элемента с индексом i в буфер.
		storage[i] = storage[j]; // Перезаписываем элемент с индексом i значением элемента с индексом j.
		storage[j] = buf; // Перезаписываем элемент с индексом j значением из буфера.
	}

	void Heap::heapify(int ix) // Метод для приведения поддерева с корнем в узле ix к виду кучи.
	{
		int l = left(ix), r = right(ix), irl = ix; // Получаем индексы левого и правого потомков узла ix, а также индекс узла с наибольшим значением.
		if (l > 0)
		{
			if (isGreat(storage[l], storage[ix])) irl = l; // Если значение левого потомка больше значения узла ix, обновляем индекс узла с наибольшим значением.
			if (r > 0 && isGreat(storage[r], storage[irl])) irl = r; // Если значение правого потомка больше значения узла с наибольшим значением, обновляем этот индекс.
			if (irl != ix) // Если индекс узла с наибольшим значением отличается от ix, обмениваем элементы в узлах ix и irl и вызываем метод heapify для узла irl.
			{
				swap(ix, irl);
				heapify(irl);
			}
		}
	}

	void Heap::insert(void* x) // Метод для вставки нового элемента x в кучу.
	{
		int i;
		if (!isFull()) // Если куча не заполнена, добавляем новый элемент.
		{
			storage[i = ++size - 1] = x; // Добавляем x в конец массива данных кучи и сохраняем его индекс в i.
			while (i > 0 && isLess(storage[parent(i)], storage[i])) // Пока индекс i не достигнет корня кучи и значение родительского узла больше значения добавленного элемента, меняем местами эти узлы.
			{
				swap(parent(i), i);
				i = parent(i);
			}
		}
	}

	void* Heap::extractMax() // Метод для извлечения максимального элемента из кучи.
	{
		void* rc = nullptr; // Инициализируем указатель rc значением nullptr.
		if (!isEmpty()) // Если куча не пуста, извлекаем максимальный элемент.
		{
			rc = storage[0]; // Сохраняем значение максимального элемента в rc.
			storage[0] = storage[size - 1]; // Перезаписываем корень кучи значением последнего элемента в куче.
			size--; // Уменьшаем размер кучи на 1.
			heapify(0); // Приводим поддерево с корнем в узле 0 к виду кучи.
		}
		return rc; // Возвращаем указатель на извлеченный максимальный элемент.
	}

	void* Heap::extractMin() // Метод для удаления минимального элемента из кучи.
	{
		void* rc = nullptr; // Инициализируем указатель rc значением nullptr.
		if (!isEmpty()) // Если куча не пуста, удаляем минимальный элемент.
		{
			// Вычисляем индекс минимального элемента.
			int index = pow(2, floor(log2(size))) - 1;
			rc = storage[index]; // Сохраняем значение минимального элемента в rc.
			storage[index] = storage[size - 1]; // Перезаписываем элемент с индексом index значением последнего элемента в куче.
			size--; // Уменьшаем размер кучи на 1.

			int i = size;
			while (i > 0 && isLess(storage[parent(i)], storage[i])) // Пока индекс i не достигнет корня кучи и значение родительского узла больше значения удаляемого элемента, меняем местами эти узлы.
			{
				swap(parent(i), i);
				i = parent(i);
			}

			heapify(0); // Приводим поддерево с корнем в узле 0 к виду кучи.
		}
		return rc; // Возвращаем указатель на удаленный минимальный элемент.
	}

	void* Heap::extractI(int index) // Метод для удаления элемента по индексу из кучи.
	{
		void* rc = nullptr; // Инициализируем указатель rc значением nullptr.
		if (!isEmpty() && index < size) // Если куча не пуста и индекс находится в пределах кучи, удаляем элемент.
		{
			rc = storage[index]; // Сохраняем значение удаляемого элемента в rc.
			storage[index] = storage[size - 1]; // Перезаписываем элемент с индексом index значением последнего элемента в куче.
			size--; // Уменьшаем размер кучи на 1.
			heapify(0); // Приводим поддерево с корнем в узле 0 к виду кучи.
		}
		return rc; // Возвращаем указатель на удаленный элемент.
	}

	Heap* Heap::unionHeap(Heap* heap) // Метод для объединения двух куч.
	{
		for (int i = 0; i < heap->size; i++) // Добавляем элементы из второй кучи в первую.
			insert(heap->storage[i]);
		return this; // Возвращаем указатель на первую кучу.
	}
	// Определение метода класса Heap для вывода значений элементов на экран
	void Heap::scan(int i) const
	{
		int probel = 20; // Инициализация переменной probel
		std::cout << '\n'; // Перевод курсора на новую строку

		// Проверка, пуста ли куча
		if (size == 0)
		{
			std::cout << "Куча пуста"; // Вывод сообщения о пустой куче
		}

		// Цикл по всем элементам кучи
		for (int u = 0, y = 0; u < size; u++)
		{
			// Вывод значения элемента на экран с отступом probel + 10
			std::cout << std::setw(probel + 10) << std::setfill(' ');
			((AAA*)storage[u])->print();

			// Если текущий индекс равен y, перевод курсора на новую строку и изменение значения y
			if (u == y)
			{
				std::cout << '\n';
				if (y == 0)
					y = 2;
				else
					y += y * 2;
			}

			// Уменьшение отступа probel вдвое
			probel /= 2;
		}

		std::cout << '\n'; // Перевод курсора на новую строку
	}
}